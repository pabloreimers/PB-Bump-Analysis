%% 
%close all
%clear all

%% load in data
base_dir = 'Z:\pablo\lpsp_vglutrnai\'; %uigetdir(); %
all_files = dir([base_dir,'\**\*imgData_reg.mat']);
all_files = natsortfiles(all_files);

%% register the image
% tic
% for i = 1:length(all_files)
%     load([all_files(i).folder,'\',all_files(i).name])
%     imgData = normcorre_regProduct(imgData,false);
%     save([all_files(i).folder,'\imgData_reg.mat'],'imgData')
%     fprintf('files done: %i / %i time elapsed: %.2f\n', i,length(all_files),toc)
% end

%% make sure that each file has a mask
for i = 1:length(all_files)
    fprintf('checking mask: %s\n',all_files(i).folder)
    clear img regProduct 

    if ~isfile([fileparts(all_files(i).folder),'\mask.mat'])
        load([all_files(i).folder,'\',all_files(i).name])

        top_pct = prctile(imgData,98,'all');
        bot_pct = prctile(imgData,5,'all');
        
        imgData(imgData>top_pct) = top_pct;
        imgData(imgData<bot_pct) = bot_pct;        

        figure(1); clf; imagesc(mean(imgData,3)); colormap(bone); axis equal tight; drawnow;
        mask = roipoly();
        save([fileparts(all_files(i).folder),'\mask.mat'],'mask')
    end
end

%% process and store all values
ft_type= 'movmean'; %the type of smoothing for fictrac data
ft_win = 10; %the window over which smoothing of fictrac data occurs. gaussian windows have std = win/5.
im_type= {'movmean','movmean'}; %there's two smoothing steps for the im data. one that smooths the summed z-stacks, another that smooths the estimated mu and rho
im_win = {5,5};
n_centroid = 16;
f0_pct = 7;
r_thresh = .1;
rho_thresh = .1;

%all_data = struct();

tic
for i = length(all_data):length(all_files)
    if i<length(all_data) && strcmp(all_files(i).folder,all_data(i).meta); continue; end %if we've already processed a file, move on
    if i < length(all_data); all_data(i+1:end+1) = all_data(i:end); end %if the current file to process is missing from the data struct, insert it to the middle by shifting all_data down 1 and rewriting all_data(i)
    % clear img regProduct 
    
    all_data(i).meta = all_files(i).folder;

    tmp = strsplit(all_files(i).folder,'\');
    fprintf('processing: %s ',tmp{end-1})
    load([all_files(i).folder,'\',all_files(i).name])
    load([fileparts(all_files(i).folder),'\mask.mat'])
    tmp2 = dir([fileparts(all_files(i).folder),'\*ficTracData_DAQ.mat']);
   
        
    load([tmp2.folder,'\',tmp2.name])
   
    tmp2 = dir([fileparts(all_files(i).folder),'\csv\trialSettings.csv']);
    tmp2 = readtable([tmp2.folder,'\',tmp2.name]);
    
    all_data(i).ft = process_ft(ftData_DAQ, ft_win, ft_type);
    all_data(i).im = process_im(imgData, im_win, im_type, mask, n_centroid, f0_pct);
    all_data(i).ft.stims = ftData_DAQ.stim{1};
    all_data(i).ft.pattern = tmp2.patternPath{1};

    
    
    dr = all_data(i).ft.r_speed;
    %dr(abs(dr)>r_thresh) = dr(abs(dr)>r_thresh) - mean(dr(abs(dr)>r_thresh));
    all_data(i).ft.heading = cumsum(dr)/60;
    

    fprintf('ETR: %.2f hours\n',toc/i * (length(all_files)-i) / 60 / 60)
end
%% calculate integrative gain
win_sec = 20;
lag = 20;
fr = 60;
win_frames = win_sec*fr;
win = [-10,10];
r_thresh = .1;
rho_thresh = .1;
g = cell(length(all_data),1);
v = cell(length(all_data),1);
hv = cell(length(all_data),1);

% counter=0;
% for i = 1:length(all_data)
%     if isempty(all_data(i).gain)
%         break
%     end
%     counter=counter+1;
% end

tic
for i = 1:length(all_data)
    if isempty(all_data(i).ft); continue; end
    fprintf('processing: %i ',i)

    %extract the best unwrapped estimate of mu by nan-ing low confidence
    %values and unwrapping and re-interp onto fictrac timescale
    m = all_data(i).im.mu;
    m(all_data(i).im.rho<rho_thresh) = nan;
    n_frames = 1:length(m);
    m = interp1(all_data(i).ft.xb(n_frames),unwrap(m),all_data(i).ft.xf);
    m = smoothdata(m,1,"gaussian",60);
    amp = interp1(all_data(i).ft.xb(n_frames),sum(all_data(i).im.d,1),all_data(i).ft.xf);

    %extract the fly's heading (no gain applied) and apply all lags
    h = reshape(all_data(i).ft.heading,[],1);
    m = reshape(m,[],1);

    m = m(lag+1:end);
    h = h(1:end-lag);
    xf= all_data(i).ft.xf(1:end-lag);


    % for each second
    % g_tmp = nan(floor((length(m) - win_frames)/fr),1);
    % v_tmp = nan(floor((length(m) - win_frames)/fr),1);
    
    xt = 0:ceil(max(all_data(i).ft.xf));
    g_tmp = nan(length(xt),1);
    v_tmp = nan(length(xt),1);
    hv_tmp = nan(length(xt),1);

    for j = 1:length(g_tmp)
        % f = j*fr;
        % h_tmp = h(f:f+win_frames);
        idx = xf > j+win(1) & xf < j+win(2);
        h_tmp = h(idx);
        m_tmp = m(idx);
        hv_tmp(j) =  circ_var(h_tmp);
        % m_tmp = m(f:f+win_frames) - m(f);
        m_tmp = m_tmp - m_tmp(1);
        fun = @(x)(circ_var(circ_dist(m_tmp,h_tmp*x),[], [], [],'omitnan')); %find the gain and bias that best fits bump position to fly position over a window
        tmp = inf;
        for k = 0:.05:5 %evaluate the loss function at many possible gains, and save gain that gives the minimum value
            if fun(k) < tmp
                g_tmp(j) = k;
                tmp = fun(k);
            end
        end
        v_tmp(j) = tmp;
        
    end

    g{i} = g_tmp;
    v{i} = v_tmp;
    hv{i} = hv_tmp;

    all_data(i).gain.g = g_tmp;
    all_data(i).gain.v = v_tmp;
    all_data(i).gain.hv = hv_tmp;
    all_data(i).gain.xt = xt;
    fprintf('ETR: %.2f hours\n',toc/i * (length(all_data)-i) / 60 / 60)
end

%% calculate sliding gain
win = [-10,10];
lag = 10;
fr = 60;
r_thresh = .1;
rho_thresh = .1;
g = cell(length(all_data),1);
v = cell(length(all_data),1);

tic
for i = 1:length(all_data)
    if isempty(all_data(i).ft); continue; end
    fprintf('processing: %i ',i)

    %extract the best unwrapped estimate of mu by nan-ing low confidence
    %values and unwrapping and re-interp onto fictrac timescale
    m = all_data(i).im.mu;
    %m(all_data(i).im.rho<rho_thresh) = nan;
    n_frames = 1:length(m);
    m = interp1(all_data(i).ft.xb(n_frames),unwrap(m),all_data(i).ft.xf);
    
    dm = gradient(m) * 60;
    dr = all_data(i).ft.r_speed;
    df = all_data(i).ft.f_speed;

    xf = all_data(i).ft.xf;
    xb = all_data(i).ft.xb;

    g_tmp = nan(length(xb),1);

    dm = dm(lag:end);
    dr = dr(1:end-lag);
    df = df(1:end-lag);
    xf = xf(1:end-lag);

    for t = 1:length(xb)
        idx = (xf > xb(t)+win(1)) & (xf < xb(t)+win(2));
        dr_tmp = dr(idx);
        df_tmp = df(idx);
        dm_tmp = dm(idx);

        % if all(all_data(i).ft.cue_brightness(idx)==0)
        %     a=1;
        % end
        %speed_corr = (dr_tmp) \ (df_tmp);
        %dr_tmp = dr_tmp - df_tmp'*speed_corr;
        

        % [r,lags]  = xcorr(dr_tmp,dm_tmp,30);
        % lag = lags(r==max(r));
        % 
        % if lag > 0
        %     dr_tmp = dr_tmp(lag:end);
        %     df_tmp = df_tmp(lag:end);
        %     dm_tmp = dm_tmp(1:end-lag+1);
        % else
        %     dr_tmp = dr_tmp(1:end+lag);
        %     df_tmp = df_tmp(1:end+lag);
        %     dm_tmp = dm_tmp(1-lag:end);
        % end

        a = [dr_tmp,df_tmp] \ dm_tmp;
        if ~isempty(dm_tmp) 
            %g_tmp(t) =  dr_tmp(~isnan(dm_tmp)) \ dm_tmp(~isnan(dm_tmp));
            g_tmp(t) = a(1);
        end
    end
    
    all_data(i).gain.inst_g = g_tmp;
    fprintf('ETR: %.2f hours\n',toc/i * (length(all_data)-i) / 60 / 60)
end

%% create meta data indexes
trial_num = zeros(length(all_data),1);
dark_idx  = false(length(all_data),1);
empty_idx = false(length(all_data),1);
mcherry_idx = false(length(all_data),1);
walk_idx  = false(length(all_data),1);
fly_num   = nan(length(all_data),1);
last_str = '';
fly_counter = 0;
for i = 1:length(all_data)
    tmp_str = all_data(i).meta(1:39);

    if ~strcmp(tmp_str,last_str)
        counter = 0;
        last_str = tmp_str;        
        fly_counter = fly_counter+1;
    end

    counter = counter+1;
    trial_num(i) = counter;
    fly_num(i) = fly_counter;
    last_str = tmp_str;
    
    if (sum(all_data(i).ft.f_speed>.1) > length(all_data(i).ft.f_speed)/5) && sum(abs(diff(unwrap(all_data(i).ft.cue)))) > 5 && mean(all_data(i).im.rho) > .4
        walk_idx(i) = true;
    end
    
    if contains(all_data(i).ft.pattern,'background')
        dark_idx(i) = true;
    end

    if contains(all_data(i).meta,'mcherry')
        mcherry_idx(i) = true;
    end
    if contains(all_data(i).meta,'empty')
        empty_idx(i) = true;
    end
end


%% create figure to show example
i = 137;
binedges = 0:.05:5;
dark_mode = false;
r_thresh = .2;

figure(1); clf
a1 = subplot(3,1,1);
imagesc(all_data(i).ft.xb,unwrap(all_data(i).im.alpha),all_data(i).im.z)
hold on
if contains(all_data(i).ft.pattern,'background'); c = 'm'; else; c = 'c'; end
a = plot(all_data(i).ft.xf,-all_data(i).ft.cue,c,'linewidth',2); a.YData(abs(diff(a.YData))>pi) = nan;
idx = round(all_data(i).ft.cue,4) == -.2945;

a = plot(all_data(i).ft.xb,all_data(i).im.mu,'w','linewidth',2); a.YData(abs(diff(a.YData))>pi) = nan;
title(all_data(i).meta,'Interpreter','none')
xlabel('time (s)')

pos = get(gca,'Position');
pos = [pos(1)+pos(3)+.01,pos(2),.05,pos(4)];
ax = axes('Position',pos,'Color','none','XAxisLocation','top'); hold on
idx = all_data(i).ft.r_speed > r_thresh;
mu  = interp1(all_data(i).ft.xb,all_data(i).im.mu,all_data(i).ft.xf);
histogram(mu(idx),-pi:.1:pi,'Orientation','horizontal','edgeColor','none','Normalization','probability')
histogram(-all_data(i).ft.cue(idx),-pi:.1:pi,'Orientation','horizontal','edgeColor','none','Normalization','probability')
box(ax,'off')
ax.YAxisLocation =  'right'; ax.YLim = [-pi,pi]; ax.YTick = [-pi,0,pi]; ax.YTickLabels = {'-\pi','0','\pi'};

a2 = subplot(6,1,3); hold on
offset = circ_dist(-all_data(i).ft.cue,interp1(all_data(i).ft.xb,unwrap(all_data(i).im.mu),all_data(i).ft.xf));
%a=plot(all_data(i).ft.xf,offset); a.YData(abs(diff(a.YData))>pi) =nan;
a=scatter(all_data(i).gain.xt,all_data(i).gain.hv,'.');
%plot(all_data(i).ft.xf,all_data(i).ft.f_speed)
% patch(all_data(i).ft.xf,2*pi*(all_data(i).ft.stims/10)-pi,'r','FaceAlpha',.1,'EdgeColor','none')
% ylabel('offset')
% %a2.YTick = [-pi,0,pi]; a2.YTickLabels = {'-\pi','0','\pi'}; a2.YLim = [-pi,pi];
% pos = get(gca,'Position');
% pos = [pos(1)+pos(3)+.01,pos(2),.05,pos(4)];
% ax = axes('Position',pos,'Color','none','XAxisLocation','top');
% histogram(offset,-pi:.1:pi,'Orientation','horizontal','edgeColor','none')
% box(ax,'off')
% ax.YAxisLocation =  'right'; ax.YLim = [-pi,pi]; ax.YTick = [-pi,0,pi]; ax.YTickLabels = {'-\pi','0','\pi'};

a3 = subplot(6,1,4); hold on
scatter(all_data(i).ft.xb,all_data(i).gain.inst_g,'.')
scatter(all_data(i).gain.xt,all_data(i).gain.g,'.')
ylabel('gain'); legend('instant','integ','autoupdate','off')

linkaxes([a1,a2,a3],'x')
xlim([min(all_data(i).ft.xb),max(all_data(i).ft.xb)])
ylim([0,5])
plot(xlim,[.8,.8],'k:'); %plot(xlim,[1.6,1.6],':k')

subplot(3,2,5); hold on
h = histogram(all_data(i).gain.g,'BinEdges',binedges,'FaceAlpha',.8,'Normalization','probability','EdgeColor','none');

xlabel('gain')
ylabel('counts')
legend('integrative','color','none','textcolor','w')

subplot(3,2,6); 
histogram(all_data(i).ft.f_speed,'edgecolor','none')
xlabel('f speed')

%% show historams in the CL and the dark (integrative gain)
c = 'k';

g = {};
for i = 1:length(all_data)
    g{i} = all_data(i).gain.g(all_data(i).gain.hv > .4 & all_data(i).gain.v < .1);
end
g = reshape(g,[],1);
mean_g = cellfun(@(x)(mean(x,'omitnan')),g);
sem_g = cellfun(@(x)(std(x,'omitnan')/sqrt(sum(~isnan(x)))),g);

figure(3); clf
for i = 0:1
    subplot(1,2,i+1); hold on
    set(gca,'color','none','ycolor',c,'xcolor',c)
    tmp = reshape(cell2mat(g(walk_idx & empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[0:.1:5],'Normalization','Probability','FaceColor',[0,.5,1],'FaceAlpha',.8)
    tmp = reshape(cell2mat(g(walk_idx & ~empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[0:.1:5],'Normalization','Probability','FaceColor',[1,.5,0],'FaceAlpha',.8)
    legend(sprintf('empty>TH-RNAi (%i)',length(unique(fly_num(walk_idx &empty_idx & dark_idx == i)))),...
           sprintf('lpsp>TH-RNAi (%i)',length(unique(fly_num(walk_idx & ~empty_idx & dark_idx == i)))),...
           'textcolor',c,'Location','Southeast')
    title(sprintf('Dark = %i',i),'Color',c)

    pos = get(gca,'Position');
    axes('Position',[pos(1)+pos(3)/2,pos(2)+pos(4)/2,pos(3)/2,pos(4)/2]); hold on
    errorbar(0*ones(sum(empty_idx & walk_idx & dark_idx==i),1),mean_g(empty_idx & walk_idx & dark_idx==i),sem_g(empty_idx & walk_idx & dark_idx==i),'o','Color',[0,.5,1,.1])
    errorbar(1*ones(sum(~empty_idx & walk_idx & dark_idx==i),1),mean_g(~empty_idx & walk_idx & dark_idx==i),sem_g(~empty_idx & walk_idx & dark_idx==i),'o','Color',[1,.5,0,.1])
    xticks([0,1]); xticklabels({'Empty','LPsP'}); ylabel('Integrative Gain')
    axis padded; set(gca,'Color','none','ycolor',c,'xcolor',c)
end


if strcmp(c,'w')
set(gcf,'color','none','InvertHardcopy','off')
end
fontsize(gcf,20,'pixels')

%% find p value by grouping identical trials
c = [1,.5,0;...
    0,.7,.7];

group_idx = [fly_num,empty_idx,dark_idx,walk_idx];
[unique_groups,~,ic] = unique(group_idx,'rows');
g_grouped = nan(length(unique_groups),1);
v_grouped = nan(length(unique_groups),1);



for i = 1:length(unique_groups)
    g_grouped(i) = mean(vertcat(g{ic==i}),'omitnan');
    v_grouped(i) = var(vertcat(g{ic==i}),'omitnan');

end

figure(5); clf
subplot(2,2,1); hold on
idx = ~unique_groups(:,3) & unique_groups(:,4);
scatter(unique_groups(idx,2),g_grouped(idx),[],c(unique_groups(idx,2)+1,:),'filled','MarkerFaceAlpha',.5)
axis padded
ylabel({'Gain','mean'},'color','w','Rotation',0)
text(0,max(ylim),sprintf('n = %i',sum(~unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
text(1,max(ylim),sprintf('n = %i',sum(unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
plot(xlim,[.8,.8],'w:')
xticks([0,1]); xticklabels({'lpsp','empty'})

subplot(2,4,5)
empty_ind = find(unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4)); %find indices to each group
lpsp_ind  = find(~unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4));
n = 1e4;
empty_mat = empty_ind(randi(length(empty_ind),length(empty_ind),n)); %create a matrix that resamples those indices across rows, and repeats this n times across columns
lpsp_mat  = lpsp_ind(randi(length(lpsp_ind),length(lpsp_ind),n));

hold on
swarmchart(ones(n,1),mean(g_grouped(empty_mat),1),'w.')
swarmchart(zeros(n,1),mean(g_grouped(lpsp_mat),1),'w.')
plot(xlim,[.8,.8],':w')
axis padded

p = sum((mean(g_grouped(empty_mat),1) - mean(g_grouped(lpsp_mat),1))>0) / n; %count how many times the mean of the empty group is higher than the mean of the lpsp group, divide by n for p value
title(sprintf('bootstrap mean\np: %.3f',p),'color','w')
xticks([0,1]); xticklabels({'lpsp','empty'})

subplot(2,4,6)
hold on
swarmchart(ones(n,1),var(g_grouped(empty_mat),1),'w.')
swarmchart(zeros(n,1),var(g_grouped(lpsp_mat),1),'w.')
axis padded

p = sum((var(g_grouped(empty_mat),1) - var(g_grouped(lpsp_mat),1))>0) / n; %count how many times the mean of the empty group is higher than the mean of the lpsp group, divide by n for p value
title(sprintf('bootstrap var\np: %.3f',p),'color','w')
xticks([0,1]); xticklabels({'lpsp','empty'})

subplot(2,2,2)
scatter(unique_groups(idx,2),v_grouped(idx),[],c(unique_groups(idx,2)+1,:),'filled','MarkerFaceAlpha',.5)
axis padded
ylabel({'Gain','variance'},'color','w','Rotation',0)
text(0,max(ylim),sprintf('n = %i',sum(~unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
text(1,max(ylim),sprintf('n = %i',sum(unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
xticks([0,1]); xticklabels({'lpsp','empty'})

subplot(2,2,4)
hold on
swarmchart(ones(n,1),mean(v_grouped(empty_mat),1),'w.')
swarmchart(zeros(n,1),mean(v_grouped(lpsp_mat),1),'w.')
axis padded


p = sum((mean(v_grouped(empty_mat),1) - mean(v_grouped(lpsp_mat),1))>0) / n; %count how many times the mean of the empty group is higher than the mean of the lpsp group, divide by n for p value
title(sprintf('bootstrap mean\np: %.3f',p),'color','w')
xticks([0,1]); xticklabels({'lpsp','empty'})

set(get(gcf,'Children'),'Color','none','xcolor','w','ycolor','w','XDir','reverse')
set(gcf,'Color','none','InvertHardCopy','off')

%%
figure(6); clf ; hold on
for i = 1:length(all_data)
    if ~empty_idx(i) && walk_idx(i) && ~dark_idx(i)
        scatter(mean(all_data(i).ft.f_speed), mean_g(i))
    end
end

%% identify index to specific trials sorted by gain
tmp_ind = find(empty_idx & walk_idx & ~dark_idx); %find the index to the trials we care about
[~,ind] = sort(mean_g(tmp_ind),'descend'); %sort the gains of those trials, and find the index

sort_ind = tmp_ind(ind); %return the indices of the trials in descending gain order. 

figure(5); clf; %show their histogram of forward speeds sorted in this order

rows = ceil(sqrt(length(sort_ind)));
cols = ceil(length(sort_ind)/rows);

for i = 1:length(sort_ind)
    subplot(rows,cols,i)
    histogram(all_data(sort_ind(i)).ft.f_speed,'EdgeColor','none','BinEdges',-3:.1:20)
    title(sprintf('trial: %i, gain:%.2f',sort_ind(i),mean_g(sort_ind(i))))
end
%% show historams in the CL and the dark (offset)
r_thresh = 0.1;
c = 'k';

o = {};
h = {};
for i = 1:length(all_data)
    tmp = circ_dist(-all_data(i).ft.cue,interp1(all_data(i).ft.xb,unwrap(all_data(i).im.mu),all_data(i).ft.xf));
    tmp_mean = atan2(mean(sin(tmp),'omitnan'),mean(cos(tmp),'omitnan'));
    tmp = tmp - tmp_mean;
    tmp(tmp<-pi) = tmp(tmp<-pi) + 2*pi;
    tmp = tmp(abs(all_data(i).ft.r_speed)>r_thresh);
    
    o{i} = tmp(~isnan(tmp));
    h{i} = all_data(i).ft.cue;
end

o = reshape(o,[],1);
h = reshape(h,[],1);

var_o = cellfun(@(x)(circ_var(x)),o);
var_h = cellfun(@(x)(circ_var(x)),h);

figure(3); clf
for i = 0:1
    subplot(1,2,i+1); hold on
    set(gca,'color','none','ycolor',c,'xcolor',c)
    tmp = reshape(cell2mat(o(walk_idx & empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[-pi:.1:pi],'Normalization','Probability','FaceColor',[0,.5,1],'FaceAlpha',.8)
    tmp = reshape(cell2mat(o(walk_idx & ~empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[-pi:.1:pi],'Normalization','Probability','FaceColor',[1,.5,0],'FaceAlpha',.8)
    legend(sprintf('empty>TH-RNAi (%i)',length(unique(fly_num(walk_idx &empty_idx & dark_idx == i)))),...
           sprintf('lpsp>TH-RNAi (%i)',length(unique(fly_num(walk_idx & ~empty_idx & dark_idx == i)))),...
           'textcolor',c)
    title(sprintf('Dark = %i',i),'Color',c)

    pos = get(gca,'Position');
    axes('Position',[pos(1)+pos(3)*.75,pos(2)+pos(4)/2,pos(3)/3,pos(4)/3]); hold on
    scatter(0*ones(sum(empty_idx & walk_idx & dark_idx==i),1),var_o(empty_idx & walk_idx & dark_idx==i),'o','Color',[0,.5,1])
    scatter(1*ones(sum(~empty_idx & walk_idx & dark_idx==i),1),var_o(~empty_idx & walk_idx & dark_idx==i),'o','Color',[1,.5,0])
    xticks([0,1]); xticklabels({'Empty','LPsP'}); ylabel('Offset Variance (Circular)')
    axis padded; set(gca,'Color','none','ycolor',c,'xcolor',c)
end

if strcmp(c,'w')
set(gcf,'color','none','InvertHardcopy','off')
end
fontsize(gcf,20,'pixels')

%% bootstrap offset variability over total heading variability
c = [1,.5,0;...
    0,.7,.7];
%group identical trials
group_idx = [fly_num,empty_idx,dark_idx,walk_idx];
[unique_groups,~,ic] = unique(group_idx,'rows');
o_grouped = nan(length(unique_groups),1);
h_grouped = nan(length(unique_groups),1);

for i = 1:length(unique_groups)
    o_grouped(i) = circ_var(vertcat(o{ic==i}));
    h_grouped(i) = circ_var(vertcat(h{ic==i}));
end

figure(5); clf
subplot(2,2,1)
idx = ~unique_groups(:,3) & unique_groups(:,4);
scatter(unique_groups(idx,2),h_grouped(idx),[],c(unique_groups(idx,2)+1,:),'filled','MarkerFaceAlpha',.5)
axis padded
ylabel({'heading', 'variance'},'color','w','Rotation',0)
text(0,max(ylim),sprintf('n = %i',sum(~unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
text(1,max(ylim),sprintf('n = %i',sum(unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')

xticks([0,1]); xticklabels({'lpsp','empty'})

subplot(2,2,3)
empty_ind = find(unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4)); %find indices to each group
lpsp_ind  = find(~unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4));
n = 1e4;
empty_mat = empty_ind(randi(length(empty_ind),length(empty_ind),n)); %create a matrix that resamples those indices across rows, and repeats this n times across columns
lpsp_mat  = lpsp_ind(randi(length(lpsp_ind),length(lpsp_ind),n));

hold on
swarmchart(ones(n,1),mean(h_grouped(empty_mat),1),'w.')
swarmchart(zeros(n,1),mean(h_grouped(lpsp_mat),1),'w.')

axis padded

p = sum((mean(h_grouped(empty_mat),1) - mean(h_grouped(lpsp_mat),1))>0) / n; %count how many times the mean of the empty group is higher than the mean of the lpsp group, divide by n for p value
title(sprintf('p: %.3f',p),'color','w')
xticks([0,1]); xticklabels({'lpsp','empty'})


subplot(2,2,2)
scatter(unique_groups(idx,2),o_grouped(idx),[],c(unique_groups(idx,2)+1,:),'filled','MarkerFaceAlpha',.5)
axis padded
ylabel({'Offset','Variance'},'color','w','Rotation',0)
xticks([])
text(0,max(ylim),sprintf('n = %i',sum(~unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
text(1,max(ylim),sprintf('n = %i',sum(unique_groups(:,2) & ~unique_groups(:,3) & unique_groups(:,4))),'HorizontalAlignment','center','color','w')
xticks([0,1]); xticklabels({'lpsp','empty'})

subplot(2,2,4)
hold on
swarmchart(ones(n,1),mean(o_grouped(empty_mat),1),'w.')
swarmchart(zeros(n,1),mean(o_grouped(lpsp_mat),1),'w.')
axis padded
xticks([0,1]); xticklabels({'lpsp','empty'})

p = sum((mean(o_grouped(empty_mat),1) - mean(o_grouped(lpsp_mat),1))>0) / n; %count how many times the mean of the empty group is higher than the mean of the lpsp group, divide by n for p value
title(sprintf('p: %.3f',p),'color','w')

linkaxes(get(gcf,'children'),'x')
set(get(gcf,'Children'),'color','none','xcolor','w','ycolor','w','XDir','reverse')
set(gcf,'Color','none','InvertHardCopy','off')

%% identify index to specific trials sorted by variance
tmp_ind = find(~empty_idx & walk_idx & ~dark_idx); %find the index to the trials we care about
[~,ind] = sort(var_o(tmp_ind),'descend'); %sort the gains of those trials, and find the index

sort_ind = tmp_ind(ind); %return the indices of the trials in descending gain order. 

figure(5); clf; %show their histogram of forward speeds sorted in this order

rows = ceil(sqrt(length(sort_ind)));
cols = ceil(length(sort_ind)/rows);

for i = 1:length(sort_ind)
    subplot(rows,cols,i)
    histogram(all_data(sort_ind(i)).ft.f_speed,'EdgeColor','none','BinEdges',-3:.1:20)
    title(sprintf('trial: %i, offset var:%.2f',sort_ind(i),var_o(sort_ind(i))))
end

%% show historams in the
% CL and the dark (bump and cue position occupancy)
m = {};
c = {};
for i = 1:length(all_data)
    tmp = all_data(i).ft.cue;
    tmp_mean = atan2(mean(sin(tmp),'omitnan'),mean(cos(tmp),'omitnan'));
    tmp = tmp - tmp_mean;
    tmp(tmp<-pi) = tmp(tmp<-pi) + 2*pi;
    c{i} = tmp(~isnan(tmp));
    
    tmp = all_data(i).im.mu;
    tmp_mean = atan2(mean(sin(tmp),'omitnan'),mean(cos(tmp),'omitnan'));
    tmp = tmp - tmp_mean;
    tmp(tmp<-pi) = tmp(tmp<-pi) + 2*pi;
    m{i} = tmp(~isnan(tmp));
end
c = reshape(c,[],1);
m = reshape(m,[],1);

figure(3); clf
t = tiledlayout(2,2);
for i = 0:1
    nexttile; hold on
    set(gca,'color','none','ycolor','w','xcolor','w')
    tmp = reshape(cell2mat(c(walk_idx & empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[-pi:.1:pi],'Normalization','Probability','FaceColor',[0,.5,1],'FaceAlpha',.8)
    tmp = reshape(cell2mat(c(walk_idx & ~empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[-pi:.1:pi],'Normalization','Probability','FaceColor',[1,.5,0],'FaceAlpha',.8)
    legend(sprintf('empty>TH-RNAi (%i)',sum(walk_idx & empty_idx & dark_idx == i)),...
           sprintf('lpsp>TH-RNAi (%i)',sum(walk_idx & ~empty_idx & dark_idx == i)),...
           'textcolor','w')
    title(sprintf('Dark = %i',i),'Color','w')
end

for i = 0:1
    nexttile; hold on
    set(gca,'color','none','ycolor','w','xcolor','w')
    tmp = reshape(cell2mat(m(walk_idx & empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[-pi:.1:pi],'Normalization','Probability','FaceColor',[0,.5,1],'FaceAlpha',.8)
    tmp = reshape(cell2mat(m(walk_idx & ~empty_idx & dark_idx == i)),1,[]);
    histogram(tmp(~isnan(tmp)),'BinEdges',[-pi:.1:pi],'Normalization','Probability','FaceColor',[1,.5,0],'FaceAlpha',.8)
    legend(sprintf('empty>TH-RNAi (%i)',sum(empty_idx & dark_idx == i)),...
           sprintf('lpsp>TH-RNAi (%i)',sum(~empty_idx & dark_idx == i)),...
           'textcolor','w')
    title(sprintf('Dark = %i',i),'Color','w')
end

title(t,'Cue Position','color','w')
set(gcf,'color','none','InvertHardcopy','off')
fontsize(gcf,20,'pixels')

%% compare entropy of cue heading, bump position, and their substraction
bin_edges = -pi:.1:pi;

ent_cue = nan(length(all_data),1);
ent_mu = nan(length(all_data),1);

for i = 1:length(all_data)
    idx = abs(all_data(i).ft.f_speed) > .01;
    ent_cue(i) = norm_entropy(all_data(i).ft.cue(idx),bin_edges);
    tmp = interp1(all_data(i).ft.xb,unwrap(all_data(i).im.mu),all_data(i).ft.xf);
    tmp = mod(tmp,2*pi);
    tmp(tmp>pi) = tmp(tmp>pi) - 2*pi;
    ent_mu(i) = norm_entropy(tmp(idx),bin_edges);
end

ent = [ent_cue,ent_mu];

figure(4); clf
t = tiledlayout(1,2);
nexttile; hold on
plot(ent(walk_idx & empty_idx & ~dark_idx,:)','Color',[0,.5,1])
plot(ent(walk_idx & ~empty_idx & ~dark_idx,:)','Color',[1,.5,0])
axis padded

nexttile; hold on
scatter(1*ones(sum(empty_idx(walk_idx & ~dark_idx)),1),ent_mu(empty_idx(walk_idx& ~dark_idx)) - ent_cue(empty_idx(walk_idx& ~dark_idx)),[],[0,.5,1])
scatter(2*ones(sum(~empty_idx(walk_idx& ~dark_idx)),1),ent_mu(~empty_idx(walk_idx& ~dark_idx)) - ent_cue(~empty_idx(walk_idx& ~dark_idx)),[],[1,.5,0])
axis padded

t.Children(2).XTick = [1,2]; t.Children(2).XTickLabel = {'Cue','Mu'}; title(t.Children(2), 'Entropy');
t.Children(1).XTick = [1,2]; t.Children(1).XTickLabel = {'Empty','LPsP'}; title(t.Children(1), 'Difference (mu-cue)');

%% show scatter of bump and fly vel for every fly
figure(8); clf
rows = ceil(sqrt(length(all_data)));
cols = ceil(length(all_data)/rows);

% rows = 2;
% cols = ceil(length(all_data)/rows);

%t = tiledlayout(rows,cols);
vel_thresh = .2;
bump_thresh = 10;
rho_thresh = .2;
vel_max = 10;
lag = 1;


group_idx = [fly_num,empty_idx,dark_idx,walk_idx];
[unique_groups,~,ic] = unique(group_idx,'rows');

vel_cell = cell(length(all_data),1);

for i = 1:length(all_data)
    
    bump_vel = interp1(all_data(i).ft.xb,gradient(unwrap(all_data(i).im.mu)) / mean(diff(all_data(i).ft.xb)),all_data(i).ft.xf);
    fly_vel =  all_data(i).ft.r_speed; % [0;diff(-all_data(i).ft.cue)] * 60;%
    rho      = interp1(all_data(i).ft.xb,all_data(i).im.rho,all_data(i).ft.xf);

    rho      = rho(lag+1:end);
    bump_vel = smoothdata(bump_vel(1+lag:end),1,'gaussian',1);
    fly_vel = smoothdata(fly_vel(1:end-lag),1,'gaussian',300);

    vel_cell{i} = [fly_vel,bump_vel,rho];
end

g = nan(size(unique_groups,1),1);
for i = 1:length(unique_groups)

    tmp         = vertcat(vel_cell{ic==i});
    fly_vel     = tmp(:,1);
    bump_vel    = tmp(:,2);
    rho         = tmp(:,3);

    idx = abs(fly_vel) > vel_thresh & abs(bump_vel) < bump_thresh & rho > rho_thresh & abs(fly_vel) < vel_max;
    
    if unique_groups(i,2); c = [0,.5,1]; else; c=[1,.5,0];end
    %nexttile
    %scatter(fly_vel(idx),bump_vel(idx),5,'filled','MarkerFaceColor',c)
    
    b = [fly_vel(idx)] \ bump_vel(idx);
    g(i) = b(1);
    plot([-2,2],b(1)+g(i)*[-2,2],'r')
    text(max(xlim),min(ylim),sprintf('gain: %.2f',g(i)),'HorizontalAlignment','right','VerticalAlignment','bottom')
end

%xlabel(t,'Fly Speed (rad/s)'); ylabel(t,'Bump Speed (rad/s)')

figure(9); hold on
c = [1,.5,0; 0,.5,1];
walk_idx2 = logical(unique_groups(:,4));
empty_idx2 = logical(unique_groups(:,2));
scatter(empty_idx2(walk_idx2),g(walk_idx2),100,c(empty_idx2(walk_idx2)+1,:),'filled','MarkerFaceAlpha',.5);ylabel({'instantaneous gain',sprintf('lag = %ims',round(lag/60*1e3))},'Rotation',0); xlim([-.5,3.5]); xticks([0:3]); xticklabels({'LPsP\newlineCL','Empty\newlineCL','LPsP\newlineDark','Empty\newlineDark'}); set(gca,'YAxisLocation','right')
errorbar(1.1,mean(g(empty_idx2 & walk_idx2)),std(g(empty_idx2 & walk_idx2))/sqrt(sum(empty_idx2 & walk_idx2)),'r')
errorbar(0.1,mean(g(~empty_idx2 & walk_idx2)),std(g(~empty_idx2 & walk_idx2))/sqrt(sum(empty_idx2 & walk_idx2)),'r')
xticklabels({'LPsP\newlineTH-RNAi\newlineCL','Empty\newlineTH-RNAi\newlineCL','LPsP\newlinevGlut-RNAi\newlineCL'});
xlim([-.5,1.5])
set(gcf,'Color','none','InvertHardCopy','off')
set(gca,'Color','none','xcolor','w','ycolor','w')
fontsize(gcf,20,'pixels')

%% extract turns from each trial
i = 151;

rot_vel         = smoothdata(all_data(i).ft.r_speed,1,'gaussian',300);
noise_thresh    = .2;
noise_std       = std(rot_vel(abs(rot_vel)<noise_thresh));
turn_start      = 5*noise_std;
turn_end        = 1*noise_std;

figure(1); clf
t = tiledlayout('vertical');
nexttile
imagesc(all_data(i).ft.xb,unwrap(all_data(i).im.alpha),all_data(i).im.z)
hold on
if contains(all_data(i).ft.pattern,'background'); c = 'm'; else; c = 'c'; end
a = plot(all_data(i).ft.xf,-all_data(i).ft.cue,c,'linewidth',2); a.YData(abs(diff(a.YData))>pi) = nan;
idx = round(all_data(i).ft.cue,4) == -.2945;

a = plot(all_data(i).ft.xb,all_data(i).im.mu,'w','linewidth',2); a.YData(abs(diff(a.YData))>pi) = nan;
title(all_data(i).meta,'Interpreter','none')
xlabel('time (s)')

nexttile; hold on
plot(all_data(i).ft.xf,rot_vel)
plot(all_data(i).ft.xf,abs(rot_vel)>turn_start)

start_inds = find(diff(abs(rot_vel)>turn_start)>0);
end_inds = find(diff(abs(rot_vel)>turn_start)<0);

if end_inds(1) < start_inds(1); start_inds = [1;start_inds]; end
if start_inds(end) > end_inds(end); end_inds = [end_inds;length(rot_vel)]; end

plot(all_data(i).ft.xf(start_inds),ones(size(start_inds)),'r*')
plot(all_data(i).ft.xf(end_inds),ones(size(end_inds)),'b*')

turn_gains = cell(size(start_inds));

dm = interp1(all_data(i).ft.xb,gradient(unwrap(all_data(i).im.mu)) / mean(diff(all_data(i).ft.xb)),all_data(i).ft.xf);

tmp_inds = start_inds(8):end_inds(8);
plot(all_data(i).ft.xf,dm)
plot(all_data(i).ft.xf,smoothdata(dm,1,'gaussian',300))
plot(all_data(i).ft.xf(tmp_inds),rot_vel(tmp_inds))
% for i = 1:length(start_inds)
%     r = rot_vel(start_ind(i):end_ind(i));
   


linkaxes(get(t,'Children'),'x')
axis tight

nexttile
scatter(rot_vel(tmp_inds),dm(tmp_inds),'.')
%% Functions

function s = process_ft(ftData_DAQ, ft_win, ft_type)

    %f_speed = ftData_dat.velFor{:};                       %store each speed
    %f_speed = interp1(ftData_dat.trialTime{1},f_speed,seconds(ftData_DAQ.trialTime{1}),'linear','extrap');
    f_speed = ftData_DAQ.velFor{:};
    r_speed = ftData_DAQ.velYaw{:};
    cue     = ftData_DAQ.cuePos{:}' / 192 * 2 * pi - pi;
    cue(abs(gradient(cue)) > 2) = nan;
    cue     = unwrap(cue);
    cue     = smoothdata(cue,1,ft_type,ft_win,'omitnan');
    cue   = mod(cue,2*pi);                                %rewrap heading data, and put between -pi and pi.
    cue(cue > pi) = cue(cue > pi) - 2*pi;
    
    s.xf      = seconds(ftData_DAQ.trialTime{:});
    if ismember('volClock',ftData_DAQ.Properties.VariableNames);
        s.xb      = seconds(ftData_DAQ.volClock{:});
    end
    s.f_speed = smoothdata(f_speed,1,ft_type,ft_win); 
    s.r_speed = smoothdata(r_speed,1,ft_type,ft_win);
    s.cue     = cue;
    
end


function x_white = whiten(x,dim)
    if nargin < 2
        dim = 1;
    end
    x_white = (x - mean(x,dim)) ./ range(x,dim);
end

function s = process_im(imgData, im_win, im_type, mask, n_centroid, f0_pct)
    
    imgData = smoothdata(imgData,3,im_type{1},im_win{1});
    imgData = imgData - min(imgData,[],'all');

    [y_mask,x_mask] = find(mask);                                             %find the cartesian coordinates of points in the mask, just to find the minimum axis length
min_axis        = min(range(x_mask),range(y_mask));
mid             = bwskel(mask,'MinBranchLength',min_axis);  %find the midline as the skeleton, shaving out all sub branches that are smaller than the minimum axis length
[y_mid,x_mid]   = find(mid);                                              %by definition, the skeleton has to be at least as long as the min width of the roi, so shave out subbranches that are shorter than that.
ep              = bwmorph(mid,'endpoints');                               %find the endpoints of the midline
[y0,x0]         = find(ep,1);

[x_mid,y_mid]   = graph_sort(x_mid,y_mid);                                      %align the points of the midline starting at the first pointpoint and going around in a circle. this requires that the midline be continuous!

xq          = [-min_axis:(length(x_mid)+min_axis)];                             %extend the midline so that it reaches the border of the mask. extrapolate as many points as the minimum axis length
x_mid       = round(interp1(1:length(x_mid),x_mid,xq,'linear','extrap'));
y_mid       = round(interp1(1:length(y_mid),y_mid,xq,'linear','extrap'));

idx         = ismember([x_mid',y_mid'],[x_mask,y_mask],'rows');                 %keep only the points that exist within the mask
x_mid       = x_mid(idx);
y_mid       = y_mid(idx);

xq          = linspace(1,length(y_mid),2*(n_centroid*2) + 1)';                        %set query points for interpolation (the number of centroids we want). we'll create twice as many points and take every other so that clusters on the edges arent clipped
centroids   = [interp1(1:length(y_mid),y_mid,xq),interp1(1:length(x_mid),x_mid,xq)];  %interpolate x and y coordinates, now that they are ordered, into evenly spaced centroids (this allows one to oversample the number of pixels, if desired)
centroids   = centroids(2:2:end-1,:);                                                     %take every other so that we dont start at the edges, and all are same size
%assign each pixel to a centroid
[~,idx] = pdist2(centroids,[y_mask,x_mask],'euclidean','smallest',1); %find the index of the centroid that is closest to each pixel in the mask. using euclidean, but maybe chebychev (chessboard)

    imgData_2d      = reshape(imgData,[],size(imgData,3));                  %reshape the data into a 2D pixels with dimensions AllPixels x Frames, where each entry is an intensity
    centroid_log    = false(2*n_centroid,size(imgData_2d,1));               %initialize a logical matrix that is of dimensions Centroids  x AllPixels
    for i = 1:2*n_centroid                                                  %For each centroid, define which pixels are contained in that centroid
        centroid_log(i, sub2ind(size(imgData),y_mask(idx==i),x_mask(idx ==i))) = true;
    end
    f_cluster       = centroid_log * double(imgData_2d) ./ sum(centroid_log,2);     %the summed fluorescence in each group will be [centroids x pixels] * [pixels  x frames], and dividing by the number of pixels in each group gives the average intensity at each frame
    f0              = prctile(f_cluster,f0_pct,2);                          %find the baseline fluorescence in each cluster
    dff_cluster     = (f_cluster - f0) ./ f0;                               %find the dF/F in each cluster. this puts everything on the same scale and eliminates baseline differences.
    zscore_cluster  = zscore(dff_cluster,[],2);
    
    alpha       = linspace(-pi,pi-(2*pi/n_centroid),n_centroid);
    alpha       = repmat(alpha,1,2);
    
    [x_tmp,y_tmp]   = pol2cart(alpha,zscore_cluster');
    [mu,rho]        = cart2pol(mean(x_tmp,2),mean(y_tmp,2));
    mu = smoothdata(unwrap(mu),1,im_type{2},im_win{2});
    mu = mod(mu,2*pi);                                %rewrap heading data, and put between -pi and pi.
    mu(mu > pi) = mu(mu > pi) - 2*pi;
    rho = smoothdata(rho,1,im_type{2},im_win{2});
    
    % imgData = squeeze(sum(imgData,3));
    % imgData = 256*(imgData-min(imgData,[],'all'))/(max(imgData,[],'all')-min(imgData,[],'all'));

    s.mu = mu;
    s.rho= rho;
    s.z  = zscore_cluster;
    s.d  = dff_cluster;
    s.f  = f_cluster;
    s.alpha = alpha;
    %s.imgData = imgData;
end

function h = plotsem(t,x,c)
    m = mean(x,1,"omitnan");
    s = std(x,[],1,'omitnan') ./ sqrt(sum(~isnan(x),1));
    t = reshape(t,1,[]);
    
    h = patch([t,fliplr(t)],[m+s,m-s],c);
end