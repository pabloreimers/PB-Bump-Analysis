%% 
close all
clear all

%% load in data
base_dir = 'Z:\pablo\lpsp_gain_chang\'; %uigetdir(); %
all_files = dir([base_dir,'\**\*imagingData.mat']);
all_files = natsortfiles(all_files);
%% make sure that each file has a mask
for i = 1:length(all_files)
    fprintf('checking mask: %s\n',all_files(i).folder)
    clear img regProduct 

    if ~isfile([fileparts(all_files(i).folder),'\mask.mat'])
        load([all_files(i).folder,'\',all_files(i).name])

        top_pct = prctile(imgData,98,'all');
        bot_pct = prctile(imgData,5,'all');
        
        imgData(imgData>top_pct) = top_pct;
        imgData(imgData<bot_pct) = bot_pct;        

        figure(1); clf; imagesc(mean(imgData,3)); colormap(bone); axis equal tight; drawnow;
        mask = roipoly();
        save([fileparts(all_files(i).folder),'\mask.mat'],'mask')
    end
end

%% process and store all values
ft_type= 'movmean'; %the type of smoothing for fictrac data
ft_win = 10; %the window over which smoothing of fictrac data occurs. gaussian windows have std = win/5.
im_type= {'movmean','movmean'}; %there's two smoothing steps for the im data. one that smooths the summed z-stacks, another that smooths the estimated mu and rho
im_win = {1,1};
n_centroid = 16;
f0_pct = 7;
r_thresh = .1;
rho_thresh = .1;

all_data = struct();

tic
for i = 1:length(all_files)
    if i<length(all_data) && strcmp(all_files(i).folder,all_data(i).meta); continue; end %if we've already processed a file, move on
    if i < length(all_data); all_data(i+1:end+1) = all_data(i:end); end %if the current file to process is missing from the data struct, insert it to the middle by shifting all_data down 1 and rewriting all_data(i)
    % clear img regProduct 
    
    all_data(i).meta = all_files(i).folder;

    tmp = strsplit(all_files(i).folder,'\');
    fprintf('processing: %s ',tmp{end-1})
    load([all_files(i).folder,'\',all_files(i).name])
    load([fileparts(all_files(i).folder),'\mask.mat'])
    tmp2 = dir([fileparts(all_files(i).folder),'\*ficTracData_DAQ.mat']);
   
        
    load([tmp2.folder,'\',tmp2.name])
   
    tmp2 = dir([fileparts(all_files(i).folder),'\csv\trialSettings.csv']);
    tmp2 = readtable([tmp2.folder,'\',tmp2.name]);
    
    all_data(i).ft = process_ft(ftData_DAQ, ft_win, ft_type);
    all_data(i).im = process_im(imgData, im_win, im_type, mask, n_centroid, f0_pct);
    all_data(i).ft.stims = ftData_DAQ.stim{1};
    all_data(i).ft.pattern = tmp2.patternPath{1};

    
    
    dr = all_data(i).ft.r_speed;
    %dr(abs(dr)>r_thresh) = dr(abs(dr)>r_thresh) - mean(dr(abs(dr)>r_thresh));
    all_data(i).ft.heading = cumsum(dr)/60;
    

    fprintf('ETR: %.2f hours\n',toc/i * (length(all_files)-i) / 60 / 60)
end
%% calculate integrative gain
win_sec = 20;
lag = 20;
fr = 60;
win_frames = win_sec*fr;
win = [-10,10];
r_thresh = .1;
rho_thresh = .1;
g = cell(length(all_data),1);
v = cell(length(all_data),1);

tic
for i = 1:length(all_data)
    if isempty(all_data(i).ft); continue; end
    fprintf('processing: %i ',i)

    %extract the best unwrapped estimate of mu by nan-ing low confidence
    %values and unwrapping and re-interp onto fictrac timescale
    m = all_data(i).im.mu;
    m(all_data(i).im.rho<rho_thresh) = nan;
    n_frames = 1:length(m);
    m = interp1(all_data(i).ft.xb(n_frames),unwrap(m),all_data(i).ft.xf);
    m = smoothdata(m,1,"gaussian",60);
    amp = interp1(all_data(i).ft.xb(n_frames),sum(all_data(i).im.d,1),all_data(i).ft.xf);

    %extract the fly's heading (no gain applied) and apply all lags
    h = reshape(all_data(i).ft.heading,[],1);
    m = reshape(m,[],1);

    m = m(lag+1:end);
    h = h(1:end-lag);
    xf= all_data(i).ft.xf(1:end-lag);


    % for each second
    % g_tmp = nan(floor((length(m) - win_frames)/fr),1);
    % v_tmp = nan(floor((length(m) - win_frames)/fr),1);
    
    xt = 0:ceil(max(all_data(i).ft.xf));
    g_tmp = nan(length(xt),1);
    v_tmp = nan(length(xt),1);

    for j = 1:length(g_tmp)
        % f = j*fr;
        % h_tmp = h(f:f+win_frames);
        idx = xf > j+win(1) & xf < j+win(2);
        h_tmp = h(idx);
        m_tmp = m(idx);
        if circ_var(h_tmp) > .1
        % m_tmp = m(f:f+win_frames) - m(f);
        m_tmp = m_tmp - m_tmp(1);
        fun = @(x)(circ_var(circ_dist(m_tmp,h_tmp*x),[], [], [],'omitnan')); %find the gain and bias that best fits bump position to fly position over a window
        tmp = inf;
        for k = 0:.05:5 %evaluate the loss function at many possible gains, and save gain that gives the minimum value
            if fun(k) < tmp
                g_tmp(j) = k;
                tmp = fun(k);
            end
        end
        v_tmp(j) = tmp;
        end
    end

    g{i} = g_tmp;
    v{i} = v_tmp;

    all_data(i).gain.g = g_tmp;
    all_data(i).gain.v = v_tmp;
    all_data(i).gain.xt = xt;
    fprintf('ETR: %.2f hours\n',toc/i * (length(all_data)-i) / 60 / 60)
end
%%

for i = 1:length(all_data)
    i
    t = 1:round(max(all_data(i).ft.xf));
    g = nan(size(t));
    r = all_data(i).ft.r_speed(1:end-2);
    c = -gradient(all_data(i).ft.cue(3:end))*60;
    c(abs(c)>50) = nan;
    for j = 1:length(t)
        idx = all_data(i).ft.xf(1:end-2) > j-1 & all_data(i).ft.xf(1:end-2) < j+5 & abs(r) > .5 & abs(c) > .5;
        
        
        if sum(idx) == 0; g(j) = nan;else; g(j) = r(idx) \ c(idx); end
    end
    g = interp1(t,g,all_data(i).ft.xf);
    all_data(i).gain.vr = g;
end

%% start by plotting the rotations in each gain category
gain_vals = [.4,.8,1.2];

figure(1); clf; hold on
tmp = nan(1,3);
for i = 1:length(all_data)
    [~,ind] = min(abs(all_data(i).gain.vr - gain_vals),[],2);
    ind(isnan(all_data(i).gain.vr)) = nan;
    for j = 1:3; 
        if sum(ind==j)/length(ind) > .1
            tmp(j) = median(abs(all_data(i).ft.r_speed(ind==j & abs(all_data(i).ft.r_speed)>.1))); 
        end
    end
    plot(gain_vals,tmp,'-','color',.9*[1,1,1,.9])
    scatter(gain_vals,tmp,100,.9*[1,1,1],'filled','MarkerFaceAlpha',.5)
end

xlim([0,1.6]); xticks(gain_vals)
xlabel('gain condition'); ylabel('median R Speed (rad/s)')

dark_fig(gcf)

%% next plot the mean fluorescence in each category
gain_vals = [.4,.8,1.2];

figure(1); clf; hold on
tmp = nan(1,3);
for i = 1:length(all_data)
    [~,ind] = min(abs(all_data(i).gain.vr - gain_vals),[],2);
    ind(isnan(all_data(i).gain.vr)) = nan;
    amp = interp1(all_data(i).ft.xb,max(all_data(i).im.d,[],1),all_data(i).ft.xf,'linear','extrap');
    r_speed = abs(all_data(i).ft.r_speed);
    
    [r,lags] = xcorr(amp,r_speed,60);
    lag = lags(r == max(r));
    
    amp = amp(lag:end);
    r_speed = r_speed(1:end-lag+1);
    ind = ind(1:end-lag+1);

    for j = 1:3
        if sum(ind==j)/length(ind) > .1
            tmp(j) = median(amp(ind==j & r_speed>.1)); 
        end
    end
    plot(gain_vals,tmp,'-','color',.9*[1,1,1,.9])
    scatter(gain_vals,tmp,100,.9*[1,1,1],'filled','MarkerFaceAlpha',.5)
end

xlim([0,1.6]); xticks(gain_vals)
xlabel('gain condition'); ylabel('median max dF/F')

dark_fig(gcf)

%% see see whether bump movement precedes or succeeds DA buildup
rho_thresh = .1;
fr = 60;
figure(9); clf; hold on
for i = 1:length(all_data)
    amp = interp1(all_data(i).ft.xb,max(all_data(i).im.d,[],1),all_data(i).ft.xf,'linear','extrap');
    dr = all_data(i).ft.r_speed;
    m = all_data(i).im.mu;
    rho= all_data(i).im.rho;
    m(rho<rho_thresh) = nan;
    m = interp1(all_data(i).ft.xb,unwrap(m),all_data(i).ft.xf);
    m = medfilt1(m,20);
    
    dm = [diff(m);0] * fr;
    dm(isnan(dm)) = 0;
    
    [r,lags] = xcorr(dr,dm,30);
    speed_lag = lags(r == max(r));
    
    [r,lags] = xcorr(amp,dm,60);
    amp_lag = lags(r == max(r));
    
    plot([1,2],[speed_lag,amp_lag]/60,'-','color',.9*[1,1,1,.9])
    if sum(all_data(i).gain.vr > 1) > sum(all_data(i).gain.vr < .6); c = 'r'; else; c='b'; end
    scatter([1,2],[speed_lag,amp_lag]/60,100,c,'filled','MarkerFaceAlpha',.5)
end
xlim([0,3]); plot([0,3],[0,0],':w')
xticks([1,2]); xticklabels({'fly speed','bump amp (peak)'})
ylabel('lag (s)')
title('optimal lag to bump speed')
dark_fig(gcf)

%% see how much dopamine you get per fly speed depending on the bump speed
win = [-10,10];

figure(10); clf; hold on

speed_slope = cell(length(all_data),1);
amp_slope = cell(length(all_data),1);
gain_key = cell(length(all_data),1);
for i = 1:length(all_data)
    [~,ind] = min(abs(all_data(i).gain.vr - gain_vals),[],2);
    ind(isnan(all_data(i).gain.vr)) = nan;
    
    amp = interp1(all_data(i).ft.xb,max(all_data(i).im.d,[],1),all_data(i).ft.xf,'linear','extrap');
    dr = all_data(i).ft.r_speed;
    m = all_data(i).im.mu;
    rho= all_data(i).im.rho;
    m(rho<rho_thresh) = nan;
    m = interp1(all_data(i).ft.xb,unwrap(m),all_data(i).ft.xf);
    m = medfilt1(m,20);
    
    dm = [0;diff(m)] * fr;
    dm(isnan(dm)) = 0;
    

    xt = 0:ceil(max(all_data(i).ft.xf));
    speed_slope{i} = nan(size(xt));
    amp_slope{i} = nan(size(xt));

    for j = 1:length(xt)
        
        idx = all_data(i).ft.xf > xt(j)+win(1) & all_data(i).ft.xf < xt(j)+win(2);
        dr_tmp = dr(idx);
        dm_tmp = dm(idx);
        ind_tmp= ind(idx);
        amp_tmp= amp(idx);

        [r,lags] = xcorr(dr_tmp,dm_tmp,30);
        lag = lags(r == max(r));
    
    if lag > 0
        ind_tmp = ind_tmp(1:end-lag);
        dr_tmp  = dr_tmp(1:end-lag);
        amp_tmp = amp_tmp(1+lag:end);
        dm_tmp  = dm_tmp(1+lag:end);
    elseif lag<0
        
        ind_tmp = ind_tmp(1-lag:end);
        dr_tmp  = dr_tmp(1-lag:end);
        amp_tmp = amp_tmp(1:end+lag);
        dm_tmp  = dm_tmp(1:end+lag);
    end
    
    idx1 = abs(dr_tmp)>.1 & abs(dm_tmp)>.1 & ~isnan(dm_tmp);
            
    gain_key{i}(j) = median(ind_tmp,'omitnan');
    speed_slope{i}(j) = dr_tmp(idx1) \ dm_tmp(idx1);
    amp_slope{i}(j) = abs(dr_tmp(idx1)) \ amp_tmp(idx1);
    end
end

%% show histogram of relationships broken up by gain condition
figure(10); clf; 

nexttile; hold on
for j = 1:3
    tmp_amp = cell2mat(amp_slope');
    tmp_key = cell2mat(gain_key');
    histogram(tmp_amp(tmp_key==j & ~isnan(tmp_amp)),'binedges',0:.02:.6,'Normalization','prob');
end
xlabel('slope dopamine peak per fly speed')
legend('.4','.8','1.2')

nexttile; hold on
tmp = nan(length(all_data),3);
for i = 1:length(all_data)
    for j = 1:3
        m = mean(amp_slope{i}(gain_key{i}==j),'omitnan');
        s = std(amp_slope{i}(gain_key{i}==j),'omitnan')/sqrt(sum(~isnan(amp_slope{i}(gain_key{i}==j))));
        errorbar(j,m,s)
        tmp(i,j) = m;
    end
end
plot(tmp','Color',[0,0,0,.1])
xlim([0,4])
xlabel('gain condition')
ylabel('amp slope')

nexttile; hold on
tmp = nan(length(all_data),3);
for i = 1:length(all_data)
    for j = 1:3
        m = mean(amp_slope{i}(gain_key{i}==j),'omitnan');
        s = std(amp_slope{i}(gain_key{i}==j),'omitnan')/sqrt(sum(~isnan(amp_slope{i}(gain_key{i}==j))));
        errorbar(j,m,s)
        tmp(i,j) = m;
    end
end
plot(tmp','Color',[0,0,0,.1])
xlim([0,4])
xlabel('bump slope')
ylabel('amp slope')


%% create a heatmap with fly speed on x, bump speed on y colored by amplitude
dr_edge = 0:.4:8;
dm_edge = 0:.4:8;

bigmat = nan(length(dm_edge),length(dr_edge),length(all_data),90);
bigidx = bigmat;

lag = 15;

for i = 1:length(all_data)

    % [~,ind] = min(abs(all_data(i).gain.vr - gain_vals),[],2);
    % ind(isnan(all_data(i).gain.vr)) = nan;

    m = all_data(i).im.mu;
    rho= all_data(i).im.rho;
    m(rho<rho_thresh) = nan;
    m = interp1(all_data(i).ft.xb,unwrap(m),all_data(i).ft.xf);
    m = medfilt1(m,20);
    dm = [0;diff(m)] * fr;
    amp = interp1(all_data(i).ft.xb,max(all_data(i).im.d,[],1),all_data(i).ft.xf,'linear','extrap');
    dr = all_data(i).ft.r_speed;

    dm = discretize(abs(dm),dm_edge);
    dr = discretize(abs(dr),dr_edge);
    dm = dm(30+1:end-lag);
    dr = dr(30+1+lag:end);

    for j = 1:90
    amp_tmp = amp(j:end-30-lag);
    dm_tmp  = dm(1:end-j+1);
    dr_tmp  = dr(1:end-j+1);
    
    for b1 = 1:length(dm_edge)
        for b2 = 1:length(dr_edge)
            bigmat(b1,b2,i,j) = mean(amp_tmp(dm_tmp == b1 & dr_tmp == b2));
        end
    end
    end
end

%%
v = VideoWriter('dopamine_buildup_heatmap.avi');
v.FrameRate = 10;
open(v);
figure(11); clf
for i = 1:90
    
    imagesc(dr_edge,dm_edge,log(mean(bigmat(:,:,:,i),3,'omitnan')),[-3,-.5])
    set(gca,'YDir','normal')
    xlabel('fly speed (rad/s)')
    ylabel('bump speed (rad/s)')
    title({'Amplitude by speeds (log mean)',sprintf('lag: %.0f ms',(i-45)/60*1000)})
    dark_fig(gcf)
    c= colorbar; c.Color = 'w';
    drawnow
    
    frame = getframe(gcf);
    writeVideo(v,frame)

end
    
close(v)

%% create a heatmap with fly speed on x, bump speed on y colored by amplitude

dr_edge = 0:.25:8;
dm_edge = 0:.25:8;

bigmat = nan(length(dm_edge),length(dr_edge),length(all_data),3);
bigidx = bigmat;
gain_vals = [.4,.8,1.2];

for i = 1:length(all_data)

    [~,ind] = min(abs(all_data(i).gain.vr - gain_vals),[],2);
    ind(isnan(all_data(i).gain.vr)) = nan;
    
    
    m = all_data(i).im.mu;
    rho= all_data(i).im.rho;
    m(rho<rho_thresh) = nan;
    m = interp1(all_data(i).ft.xb,unwrap(m),all_data(i).ft.xf);
    m = medfilt1(m,20);
    dm = [0;diff(m)] * fr;
    amp = interp1(all_data(i).ft.xb,max(all_data(i).im.d,[],1),all_data(i).ft.xf,'linear','extrap');
    dr = all_data(i).ft.r_speed;

    dm = discretize(abs(dm),dm_edge);
    dr = discretize(abs(dr),dr_edge);

    dm = dm(1:end-lag-10);
    dr = dr(1+lag:end-10);
    amp = amp(11:end-lag);
    ind = ind(1+lag:end-10);

    for b1 = 1:length(dm_edge)
        for b2 = 1:length(dr_edge)
            for g = 1:3
                bigmat(b1,b2,i,g) = mean(amp(dm == b1 & dr == b2 & ind==g));
            end
        end
    end
end

%%
figure(12); clf
for i = 1:3
    nexttile
imagesc(dr_edge,dm_edge,log(mean(bigmat(:,:,:,i),3,'omitnan')),[-3,-.25])
set(gca,'YDir','normal')
xlabel('fly speed (rad/s)')
ylabel('bump speed (rad/s)')
title(sprintf('gain = %.2f',gain_vals(i)))
c = colorbar; c.Color = 'w';
end

dark_fig(gcf)
%% plot peak fluorescence as a function of fly speed and bump speed
i = 20;
lag = 20;
figure(3); clf
m = all_data(i).im.mu;
rho= all_data(i).im.rho;
m(rho<rho_thresh) = nan;
m = interp1(all_data(i).ft.xb,unwrap(m),all_data(i).ft.xf);
m = medfilt1(m,20);

dm = [diff(m);0] * fr;
dr = all_data(i).ft.r_speed;
c = -unwrap(all_data(i).ft.cue);
dc = [diff(c);0] * fr;
amp= interp1(all_data(i).ft.xb,sum(all_data(i).im.d,1),all_data(i).ft.xf);
rho= interp1(all_data(i).ft.xb,all_data(i).im.rho,all_data(i).ft.xf);

dm = dm(lag+1:end);
dr = dr(1:end-lag);
dc = dc(1:end-lag);
amp = amp(lag+1:end);
rho = rho(lag+1:end);
g = all_data(i).gain.vr(1:end-lag) > .5;

idx = rho > rho_thresh & abs(dr) > r_thresh & ~isnan(dm);
subplot(3,2,1)
scatter(dr(idx),dm(idx),[],g(idx),'filled','MarkerFaceAlpha',.1)
xlabel('fly speed')
ylabel('bump speed')
axis equal

subplot(3,2,2)
scatter(abs(dr(idx)),abs(dc(idx)),[],amp(idx),'filled','MarkerFaceAlpha',.1)
xlabel('fly speed')
ylabel('cue speed')
axis equal

ax1= subplot(6,1,3); hold on
plot(all_data(i).ft.xb,max(all_data(i).im.z,[],1))
scatter(all_data(i).ft.xf,all_data(i).gain.vr,'.')
legend('z-dff (peak)','vr gain','autoupdate','off','color','none','textcolor','w')
%plot(-gradient(all_data(1).ft.cue(3:end))*60 ./ all_data(1).ft.r_speed(1:end-2))
%ylim([0,1.5])
title(all_data(i).meta)

ax2 = subplot(6,1,4);
plot(all_data(i).ft.xf,abs(all_data(i).ft.r_speed)); ylabel('r speed (mm/s)')

ax3 = subplot(3,1,3);
imagesc(all_data(i).ft.xb,unwrap(all_data(i).im.alpha),all_data(i).im.d)
hold on
if contains(all_data(i).ft.pattern,'background'); c = 'm'; else; c = 'c'; end
a = plot(all_data(i).ft.xf,-all_data(i).ft.cue,c); a.YData(abs(diff(a.YData))>pi) = nan;
a = plot(all_data(i).ft.xb,all_data(i).im.mu,'w'); a.YData(abs(diff(a.YData))>pi) = nan;
xlabel('time (s)')
linkaxes([ax1,ax2,ax3],'x')
axis tight

dark_fig(gcf)

%% analyze the relationship between DA and bump turn

%% plot amp vel relationship separated by gain
rows = ceil(sqrt(length(all_data)));
cols = ceil(length(all_data)/rows);

figure(5); clf
tax = tiledlayout(rows,cols);
for i= 1:length(all_data)
    dr = all_data(i).ft.r_speed;
    amp= interp1(all_data(i).ft.xb,max(all_data(i).im.d,[],1),all_data(i).ft.xf);
    dr = dr(1:end-lag);
    amp = amp(lag+1:end);

    t = 1:round(max(all_data(i).ft.xf));
    g = nan(size(t));
    r = all_data(i).ft.r_speed(1:end-2);
    c = -gradient(all_data(i).ft.cue(3:end))*60;
    c(abs(c)>50) = nan;
    for j = 1:length(t)
        idx = all_data(i).ft.xf(1:end-2) > j-1 & all_data(i).ft.xf(1:end-2) < j+5 & abs(r) > .5 & abs(c) > .5;
        
        g(j) = r(idx) \ c(idx);
        if sum(idx) == 0; g(j) = nan; end
    end
    g = interp1(t,g,all_data(i).ft.xf);
    g = g(lag+1:end);

    nexttile; hold on
    scatter(abs(dr(g>1)),amp(g>1),'filled','r','MarkerFaceAlpha',.2)
    scatter(abs(dr(g>.5 & g<1)),amp(g>.5 & g<1),'filled','b','MarkerFaceAlpha',.2)
    scatter(abs(dr(g<.5)),amp(g<.5),'filled','g','MarkerFaceAlpha',.2)
    title(all_data(i).meta(34:47))
end
legend('high','normal','low')
xlabel(tax,'fly speed (mm/s)')
ylabel(tax,'bump amp (peak dff)')
fontsize(gcf,20,'pixels')

%% Functions
%% Functions

function s = process_ft(ftData_DAQ, ft_win, ft_type)

    %f_speed = ftData_dat.velFor{:};                       %store each speed
    %f_speed = interp1(ftData_dat.trialTime{1},f_speed,seconds(ftData_DAQ.trialTime{1}),'linear','extrap');
    f_speed = ftData_DAQ.velFor{:};
    r_speed = ftData_DAQ.velYaw{:};
    cue     = ftData_DAQ.cuePos{:}' / 192 * 2 * pi - pi;
    cue(abs(gradient(cue)) > 2) = nan;
    cue     = unwrap(cue);
    cue     = smoothdata(cue,1,ft_type,ft_win,'omitnan');
    cue   = mod(cue,2*pi);                                %rewrap heading data, and put between -pi and pi.
    cue(cue > pi) = cue(cue > pi) - 2*pi;
    
    s.xf      = seconds(ftData_DAQ.trialTime{:});
    if ismember('volClock',ftData_DAQ.Properties.VariableNames);
        s.xb      = seconds(ftData_DAQ.volClock{:});
    end
    s.f_speed = smoothdata(f_speed,1,ft_type,ft_win); 
    s.r_speed = smoothdata(r_speed,1,ft_type,ft_win);
    s.cue     = cue;
    
end


function x_white = whiten(x,dim)
    if nargin < 2
        dim = 1;
    end
    x_white = (x - mean(x,dim)) ./ range(x,dim);
end

function s = process_im(imgData, im_win, im_type, mask, n_centroid, f0_pct)
    
    imgData = smoothdata(imgData,3,im_type{1},im_win{1});
    imgData = imgData - min(imgData,[],'all');

    [y_mask,x_mask] = find(mask);                                             %find the cartesian coordinates of points in the mask, just to find the minimum axis length
min_axis        = min(range(x_mask),range(y_mask));
mid             = bwskel(mask,'MinBranchLength',min_axis);  %find the midline as the skeleton, shaving out all sub branches that are smaller than the minimum axis length
[y_mid,x_mid]   = find(mid);                                              %by definition, the skeleton has to be at least as long as the min width of the roi, so shave out subbranches that are shorter than that.
ep              = bwmorph(mid,'endpoints');                               %find the endpoints of the midline
[y0,x0]         = find(ep,1);

[x_mid,y_mid]   = graph_sort(x_mid,y_mid);                                      %align the points of the midline starting at the first pointpoint and going around in a circle. this requires that the midline be continuous!

xq          = [-min_axis:(length(x_mid)+min_axis)];                             %extend the midline so that it reaches the border of the mask. extrapolate as many points as the minimum axis length
x_mid       = round(interp1(1:length(x_mid),x_mid,xq,'linear','extrap'));
y_mid       = round(interp1(1:length(y_mid),y_mid,xq,'linear','extrap'));

idx         = ismember([x_mid',y_mid'],[x_mask,y_mask],'rows');                 %keep only the points that exist within the mask
x_mid       = x_mid(idx);
y_mid       = y_mid(idx);

xq          = linspace(1,length(y_mid),2*(n_centroid*2) + 1)';                        %set query points for interpolation (the number of centroids we want). we'll create twice as many points and take every other so that clusters on the edges arent clipped
centroids   = [interp1(1:length(y_mid),y_mid,xq),interp1(1:length(x_mid),x_mid,xq)];  %interpolate x and y coordinates, now that they are ordered, into evenly spaced centroids (this allows one to oversample the number of pixels, if desired)
centroids   = centroids(2:2:end-1,:);                                                     %take every other so that we dont start at the edges, and all are same size
%assign each pixel to a centroid
[~,idx] = pdist2(centroids,[y_mask,x_mask],'euclidean','smallest',1); %find the index of the centroid that is closest to each pixel in the mask. using euclidean, but maybe chebychev (chessboard)

    imgData_2d      = reshape(imgData,[],size(imgData,3));                  %reshape the data into a 2D pixels with dimensions AllPixels x Frames, where each entry is an intensity
    centroid_log    = false(2*n_centroid,size(imgData_2d,1));               %initialize a logical matrix that is of dimensions Centroids  x AllPixels
    for i = 1:2*n_centroid                                                  %For each centroid, define which pixels are contained in that centroid
        centroid_log(i, sub2ind(size(imgData),y_mask(idx==i),x_mask(idx ==i))) = true;
    end
    f_cluster       = centroid_log * double(imgData_2d) ./ sum(centroid_log,2);     %the summed fluorescence in each group will be [centroids x pixels] * [pixels  x frames], and dividing by the number of pixels in each group gives the average intensity at each frame
    f0              = prctile(f_cluster,f0_pct,2);                          %find the baseline fluorescence in each cluster
    dff_cluster     = (f_cluster - f0) ./ f0;                               %find the dF/F in each cluster. this puts everything on the same scale and eliminates baseline differences.
    zscore_cluster  = zscore(dff_cluster,[],2);
    
    alpha       = linspace(-pi,pi-(2*pi/n_centroid),n_centroid);
    alpha       = repmat(alpha,1,2);
    
    [x_tmp,y_tmp]   = pol2cart(alpha,zscore_cluster');
    [mu,rho]        = cart2pol(mean(x_tmp,2),mean(y_tmp,2));
    mu = smoothdata(unwrap(mu),1,im_type{2},im_win{2});
    mu = mod(mu,2*pi);                                %rewrap heading data, and put between -pi and pi.
    mu(mu > pi) = mu(mu > pi) - 2*pi;
    rho = smoothdata(rho,1,im_type{2},im_win{2});
    
    % imgData = squeeze(sum(imgData,3));
    % imgData = 256*(imgData-min(imgData,[],'all'))/(max(imgData,[],'all')-min(imgData,[],'all'));

    s.mu = mu;
    s.rho= rho;
    s.z  = zscore_cluster;
    s.d  = dff_cluster;
    s.f  = f_cluster;
    s.alpha = alpha;
    %s.imgData = imgData;
end

function h = plotsem(t,x,c)
    m = mean(x,1,"omitnan");
    s = std(x,[],1,'omitnan') ./ sqrt(sum(~isnan(x),1));
    t = reshape(t,1,[]);
    
    h = patch([t,fliplr(t)],[m+s,m-s],c);
end
function h = dark_fig(f)
    ax = findall(f,'type','axes');
    for j = 1:length(ax)
        set(ax,'color','none','ycolor','w','xcolor','w')
        ax(j).Title.Color = 'w';
    end
    set(f,'Color','none','InvertHardcopy','off')
    fontsize(gcf,20,'pixels')
end